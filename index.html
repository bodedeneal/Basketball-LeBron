<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Camera Invisible Keyboard — Prototype (Two Hands)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1724;
      --accent:#22c1c3;
      --muted:#94a3b8;
      --key:#1e293b;
      --key-active:#065f60;
      --white:#e6eef6;
    }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,var(--bg),#071020); color:var(--white)}
    .app{
      max-width:1100px;margin:18px auto;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6);
    }
    header{display:flex;align-items:center;gap:12px}
    h1{margin:0;font-size:18px}
    .controls{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
    button, select{
      background:var(--panel);color:var(--white);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;cursor:pointer;
    }
    button.small{padding:6px 8px;font-size:13px}
    .stage{display:flex;gap:16px;margin-top:16px;align-items:flex-start}
    .video-wrap{position:relative;flex:1;min-width:320px;max-width:800px;background:#000;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
    video{display:block; width:100%; height:auto; transform:scaleX(-1)} /* mirrored */
    canvas{position:absolute;left:0;top:0;pointer-events:none; width:100%; height:100%}
    .side{width:320px;min-width:220px}
    .textbox{width:100%;height:150px;background:#071228;border-radius:8px;padding:10px;color:var(--white);border:1px solid rgba(255,255,255,0.03);resize:vertical; font-size:15px}
    .hint{color:var(--muted);font-size:13px;margin-top:8px}
    .row{display:flex;gap:6px;margin-top:8px}
    .kbd-mode{display:flex;gap:8px;align-items:center}
    .key-count{font-size:13px;color:var(--muted)}
    footer{margin-top:12px;color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <svg width="32" height="32" viewBox="0 0 24 24" fill="none" style="opacity:.95">
        <path d="M3 12h18" stroke="#22c1c3" stroke-width="2" stroke-linecap="round"></path>
        <path d="M8 5h8" stroke="#94a3b8" stroke-width="1.6" stroke-linecap="round"></path>
      </svg>
      <div>
        <h1>Camera Invisible Keyboard — Prototype (Two Hands)</h1>
        <div style="color:var(--muted);font-size:13px">Tracks two hands. Left hand is orange, right hand is blue. When a major movement is detected, the last key each hand hovered over is typed.</div>
      </div>
    </header>

    <div class="controls">
      <button id="btn-start" class="small">Start Camera</button>
      <button id="btn-stop" class="small" disabled>Stop</button>
      <button id="btn-clear" class="small">Clear Text</button>
      <button id="btn-copy" class="small">Copy to clipboard</button>
      <label style="display:flex;align-items:center;gap:6px;color:var(--muted);margin-left:6px">
        <input id="mirror" type="checkbox" checked /> Mirror
      </label>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <label style="color:var(--muted)">Tap velocity</label>
        <input id="vel" type="range" min="2" max="30" value="10" />
      </div>
    </div>

    <div class="stage">
      <div class="video-wrap" id="videoWrap">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="side">
        <div>
          <textarea id="typed" class="textbox" placeholder="Typed text will appear here..." readonly></textarea>
          <div class="hint">Tip: position each hand's index finger above the virtual keyboard. Make a quick, major movement (flick) to "tap". The letter typed is the last key that finger was hovering over before the movement.</div>
          <div class="row">
            <div class="kbd-mode">
              <label class="key-count">Layout:</label>
              <select id="layout">
                <option value="qwerty">QWERTY (default)</option>
                <option value="numeric">Numeric (10 keys)</option>
              </select>
            </div>
          </div>

          <div class="row">
            <button id="btn-calibrate">Calibrate Keyboard Area</button>
            <button id="btn-reset-cal">Reset Area</button>
          </div>

          <div class="row" style="margin-top:10px">
            <button id="btn-save" title="Save current text to localStorage">Save text</button>
            <button id="btn-load" title="Load saved text from localStorage">Load saved</button>
            <button id="btn-download" title="Download index.html and run locally">Download (single-file)</button>
          </div>

        </div>
      </div>
    </div>

    <footer>
      Prototype: two-hand heuristic detection. For production, consider depth sensors, markers, or ML classifiers for better accuracy.
    </footer>
  </div>

  <!-- MediaPipe scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
  // Two-hand prototype:
  // - Left hand renders orange, right hand renders blue
  // - Each hand remembers the last key it hovered over
  // - When a "major" movement (velocity) is detected for a hand, the last-hovered key for that hand is typed

  (function(){
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('btn-start');
    const stopBtn = document.getElementById('btn-stop');
    const copyBtn = document.getElementById('btn-copy');
    const clearBtn = document.getElementById('btn-clear');
    const typed = document.getElementById('typed');
    const velRange = document.getElementById('vel');
    const mirrorToggle = document.getElementById('mirror');
    const layoutSelect = document.getElementById('layout');
    const calBtn = document.getElementById('btn-calibrate');
    const resetCalBtn = document.getElementById('btn-reset-cal');

    let camera = null;
    let hands = null;
    let videoWidth = 640, videoHeight = 480;
    let cooldown = 350; // ms between taps per hand
    let keyboardArea = null; // {x,y,w,h} in pixels on canvas
    let isCalibrating = false;
    let calStart = null;
    let lastKeyPressed = null;

    // Colors for hands
    const COLORS = {
      Left: {fill: '#ff8a00', stroke: '#ffb480'},   // orange (left)
      Right: {fill: '#2aa4ff', stroke: '#8fd7ff'}   // blue (right)
    };

    // State per hand by handedness label ("Left" / "Right")
    const handState = {
      Left: { lastIndexY: null, lastTs: null, lastHoveredKey: null, lastTapTs: 0 },
      Right: { lastIndexY: null, lastTs: null, lastHoveredKey: null, lastTapTs: 0 }
    };

    // Keyboard rows (qwerty) simple layout — adaptive to keyboardArea
    const layouts = {
      qwerty: [
        "qwertyuiop".split(''),
        "asdfghjkl".split(''),
        "zxcvbnm".split(''),
        ["Space"]
      ],
      numeric: [
        ["1","2","3","4","5"],
        ["6","7","8","9","0"],
        ["-","/",".","Enter"]
      ]
    };

    function fitCanvas(){
      const wrap = document.getElementById('videoWrap');
      canvas.width = wrap.clientWidth;
      canvas.height = wrap.clientHeight;
      videoWidth = canvas.width; videoHeight = canvas.height;
    }

    window.addEventListener('resize', fitCanvas);

    function drawKeyboard(){
      if(!keyboardArea){
        // default: bottom 35% of canvas
        keyboardArea = {
          x: canvas.width * 0.05,
          y: canvas.height * 0.60,
          w: canvas.width * 0.9,
          h: canvas.height * 0.35
        };
      }
      const L = layouts[layoutSelect.value] || layouts.qwerty;
      ctx.save();
      // keyboard background
      ctx.fillStyle = 'rgba(10,12,16,0.5)';
      ctx.fillRect(keyboardArea.x, keyboardArea.y, keyboardArea.w, keyboardArea.h);
      // draw rows
      const rows = L.length;
      const rowH = keyboardArea.h / rows;
      for(let r=0;r<rows;r++){
        const row = L[r];
        const cols = row.length;
        const padding = 6;
        const keyW = (keyboardArea.w - (cols+1)*padding) / cols;
        for(let c=0;c<cols;c++){
          const kx = keyboardArea.x + padding + c*(keyW + padding);
          const ky = keyboardArea.y + r*rowH + padding/1.5;
          const kw = (r === rows-1 && row[0] === "Space") ? keyboardArea.w - padding*2 : keyW;
          const kh = rowH - padding*1.5;
          const label = row[c];

          // check hover highlights from both hands
          let hoverColor = null;
          for(const labelKey of ['Left','Right']){
            const h = handState[labelKey];
            if(h && h.lastHoveredKey && h.lastHoveredKey.row === r && h.lastHoveredKey.col === c){
              hoverColor = COLORS[labelKey].fill;
              break; // if both hover same key, picks the first (Left priority). We could composite if desired.
            }
          }

          // key background
          if(hoverColor){
            ctx.fillStyle = hexToRgba(hoverColor, 0.9);
          } else {
            ctx.fillStyle = 'rgba(30,41,59,0.88)';
          }
          ctx.strokeStyle = "rgba(255,255,255,0.03)";
          roundRect(ctx, kx, ky, kw, kh, 8, true, true);

          // label
          ctx.fillStyle = '#e6eef6';
          ctx.font = `${Math.max(14, kh*0.45)}px system-ui`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const tx = kx + kw/2;
          const ty = ky + kh/2;
          ctx.fillText(label, tx, ty);
        }
      }
      // border
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.strokeRect(keyboardArea.x, keyboardArea.y, keyboardArea.w, keyboardArea.h);
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      if (typeof r === 'undefined') r = 5;
      if (typeof r === 'number') r = {tl: r, tr: r, br: r, bl: r};
      ctx.beginPath();
      ctx.moveTo(x + r.tl, y);
      ctx.lineTo(x + w - r.tr, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
      ctx.lineTo(x + w, y + h - r.br);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
      ctx.lineTo(x + r.bl, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
      ctx.lineTo(x, y + r.tl);
      ctx.quadraticCurveTo(x, y, x + r.tl, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function hexToRgba(hex, alpha){
      // simple hex to rgba helper
      const c = hex.replace('#','');
      const r = parseInt(c.substring(0,2),16);
      const g = parseInt(c.substring(2,4),16);
      const b = parseInt(c.substring(4,6),16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function getKeyAt(x,y){
      if(!keyboardArea) return null;
      const L = layouts[layoutSelect.value] || layouts.qwerty;
      const relX = x - keyboardArea.x;
      const relY = y - keyboardArea.y;
      if(relX<0 || relY<0 || relX>keyboardArea.w || relY>keyboardArea.h) return null;
      const rows = L.length;
      const rowH = keyboardArea.h / rows;
      const r = Math.floor(relY / rowH);
      const row = L[r];
      const cols = row.length;
      const padding = 6;
      const keyW = (keyboardArea.w - (cols+1)*padding) / cols;
      for(let c=0;c<cols;c++){
        const kx = padding + c*(keyW + padding);
        const ky = r*rowH + padding/1.5;
        const kw = (r === rows-1 && row[0] === "Space") ? keyboardArea.w - padding*2 : keyW;
        const kh = rowH - padding*1.5;
        if(relX >= kx && relX <= kx+kw && relY >= ky && relY <= ky+kh){
          return {row:r,col:c,label:row[c],keyX:keyboardArea.x+kx,keyY:keyboardArea.y+ky,keyW:kw,keyH:kh};
        }
      }
      return null;
    }

    function registerKey(k){
      if(!k) return;
      const label = k.label;
      if(label === "Space") typed.value += " ";
      else if(label === "Enter") typed.value += "\n";
      else typed.value += label;
      lastKeyPressed = {row:k.row,col:k.col};
      setTimeout(()=>{ lastKeyPressed = null }, 120);
    }

    // onResults processes up to 2 hands and applies two-hand logic
    function onResults(results){
      fitCanvas();
      ctx.clearRect(0,0,canvas.width, canvas.height);
      drawKeyboard();

      // faint camera overlay for context
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();

      // Prepare hovered reset for hands not seen this frame (we don't clear hovered until we see the hand move out of keyboard)
      const seenHands = new Set();

      if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0){
        for(let i=0;i<results.multiHandLandmarks.length;i++){
          const landmarks = results.multiHandLandmarks[i];
          const handed = (results.multiHandedness && results.multiHandedness[i] && results.multiHandedness[i].label) ? results.multiHandedness[i].label : (i===0 ? 'Right' : 'Left');
          const state = handState[handed] || (handState[handed] = { lastIndexY:null, lastTs:null, lastHoveredKey:null, lastTapTs:0 });
          seenHands.add(handed);

          // index finger tip landmark index 8
          const idx = landmarks[8];
          let ix = idx.x * canvas.width;
          let iy = idx.y * canvas.height;
          if(mirrorToggle.checked){
            ix = canvas.width - ix;
          }

          // draw connectors / landmarks with hand color
          const colorFill = COLORS[handed] ? COLORS[handed].fill : '#ffffff';
          const colorStroke = COLORS[handed] ? COLORS[handed].stroke : '#ffffff';

          drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: colorStroke, lineWidth:2});
          drawLandmarks(ctx, landmarks, {color: colorFill, lineWidth:1, radius:2});

          // draw fingertip pointer emphasized
          ctx.beginPath();
          ctx.fillStyle = hexToRgba(colorFill, 0.96);
          ctx.arc(ix, iy, 10, 0, Math.PI*2);
          ctx.fill();

          // update hovered key (finger position)
          const hovered = getKeyAt(ix, iy);
          if(hovered){
            // attach row/col to stored object
            state.lastHoveredKey = { row: hovered.row, col: hovered.col, label: hovered.label, keyX: hovered.keyX, keyY: hovered.keyY, keyW: hovered.keyW, keyH: hovered.keyH };
          }

          // compute "major movement" by velocity of y (dy/dt). Positive dy = moving downwards on canvas
          const now = performance.now();
          if(state.lastIndexY !== null && state.lastTs !== null){
            const dt = Math.max(1, now - state.lastTs);
            const dy = iy - state.lastIndexY;
            const velocity = (dy / dt) * 1000; // px / sec approx
            const velThreshold = parseFloat(velRange.value) * 60; // tunable multiplier

            // major movement => velocity magnitude exceeds threshold
            if(Math.abs(velocity) > velThreshold && (now - state.lastTapTs) > cooldown){
              // register the last hovered key (the key the finger was above before the movement)
              if(state.lastHoveredKey){
                registerKey(state.lastHoveredKey);
                state.lastTapTs = now;
              }
            }
          }

          state.lastIndexY = iy;
          state.lastTs = now;
        }
      }

      // If a hand was not seen this frame, we keep its lastHoveredKey so that if it re-enters quickly it still has context.
      // Optionally, we could clear hovered for hands not seen for a while (not implemented here).

    }

    function startCamera(){
      if(camera) return;
      // initialize MediaPipe Hands
      hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }
      });
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });
      hands.onResults(onResults);

      camera = new Camera(video, {
        onFrame: async () => {
          await hands.send({image: video});
        },
        width: 1280,
        height: 720
      });
      camera.start();
      startBtn.disabled = true;
      stopBtn.disabled = false;
    }

    function stopCamera(){
      if(camera){
        camera.stop();
        camera = null;
      }
      if(hands){
        hands.close();
        hands = null;
      }
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }

    // calibration: click-drag on overlay to set keyboardArea
    canvas.addEventListener('pointerdown', (ev)=>{
      if(!isCalibrating) return;
      calStart = {x:ev.offsetX, y:ev.offsetY};
    });
    canvas.addEventListener('pointerup', (ev)=>{
      if(!isCalibrating || !calStart) return;
      const x1 = Math.min(calStart.x, ev.offsetX);
      const x2 = Math.max(calStart.x, ev.offsetX);
      const y1 = Math.min(calStart.y, ev.offsetY);
      const y2 = Math.max(calStart.y, ev.offsetY);
      keyboardArea = {x:x1, y:y1, w:x2-x1, h:y2-y1};
      isCalibrating = false;
      calStart = null;
      calBtn.textContent = "Calibrate Keyboard Area";
    });

    calBtn.addEventListener('click', ()=>{
      isCalibrating = !isCalibrating;
      calBtn.textContent = isCalibrating ? "Click-drag on video to set area..." : "Calibrate Keyboard Area";
    });

    resetCalBtn.addEventListener('click', ()=>{
      keyboardArea = null;
    });

    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);

    copyBtn.addEventListener('click', async ()=>{
      try{
        await navigator.clipboard.writeText(typed.value);
        copyBtn.textContent = "Copied!";
        setTimeout(()=>copyBtn.textContent = "Copy to clipboard", 1000);
      } catch(e){
        alert("Copy failed: " + e);
      }
    });

    clearBtn.addEventListener('click', ()=>{ typed.value = ""; });

    layoutSelect.addEventListener('change', ()=>{ /* redraw next frame */ });

    // simple save/load localStorage
    document.getElementById('btn-save').addEventListener('click', ()=>{ localStorage.setItem('camkb_text', typed.value); alert('Saved'); });
    document.getElementById('btn-load').addEventListener('click', ()=>{ typed.value = localStorage.getItem('camkb_text') || ""; });

    // download page (single-file) -- just trigger a blob download of current HTML (this file itself)
    document.getElementById('btn-download').addEventListener('click', ()=>{
      const doctype = "<!doctype html>\n";
      const html = document.documentElement.outerHTML;
      const blob = new Blob([doctype+html], {type:'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'cam-invisible-keyboard-two-hands.html';
      a.click();
      URL.revokeObjectURL(url);
    });

    // initial sizing and defaults
    fitCanvas();
    keyboardArea = null; // will default when drawing
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
  })();
  </script>
</body>
</html>
