<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Camera Invisible Keyboard — Prototype (Gestures & Multi-finger)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1724;
      --accent:#22c1c3;
      --muted:#94a3b8;
      --white:#e6eef6;
    }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,var(--bg),#071020); color:var(--white)}
    .app{
      max-width:1100px;margin:18px auto;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6);
    }
    header{display:flex;align-items:center;gap:12px}
    h1{margin:0;font-size:18px}
    .controls{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
    button, select{
      background:var(--panel);color:var(--white);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;cursor:pointer;
    }
    button.small{padding:6px 8px;font-size:13px}
    .stage{display:flex;gap:16px;margin-top:16px;align-items:flex-start}
    .video-wrap{position:relative;flex:1;min-width:320px;max-width:800px;background:#000;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
    video{display:block; width:100%; height:auto; transform:scaleX(-1)} /* mirrored */
    canvas{position:absolute;left:0;top:0;pointer-events:none; width:100%; height:100%}
    .side{width:320px;min-width:220px}
    .textbox{width:100%;height:150px;background:#071228;border-radius:8px;padding:10px;color:var(--white);border:1px solid rgba(255,255,255,0.03);resize:vertical; font-size:15px}
    .hint{color:var(--muted);font-size:13px;margin-top:8px}
    .row{display:flex;gap:6px;margin-top:8px}
    .kbd-mode{display:flex;gap:8px;align-items:center}
    .key-count{font-size:13px;color:var(--muted)}
    footer{margin-top:12px;color:var(--muted);font-size:13px}
    .toast {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 13px;
      pointer-events: none;
      opacity: 0;
      transition: opacity .18s;
    }
    .toast.show { opacity: 1; }
    .legend { font-size:12px;color:var(--muted); margin-top:8px; display:flex; gap:8px; flex-wrap:wrap }
    .legend .dot { width:12px;height:12px;border-radius:50%;display:inline-block; margin-right:6px; vertical-align:middle }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <svg width="32" height="32" viewBox="0 0 24 24" fill="none" style="opacity:.95">
        <path d="M3 12h18" stroke="#22c1c3" stroke-width="2" stroke-linecap="round"></path>
        <path d="M8 5h8" stroke="#94a3b8" stroke-width="1.6" stroke-linecap="round"></path>
      </svg>
      <div>
        <h1>Camera Invisible Keyboard — Gestures & Multi-finger</h1>
        <div style="color:var(--muted);font-size:13px">Pinch thumb+index to cycle keyboard layouts. Index types letters, middle deletes (backspace), thumb inserts Enter. Works per-hand (left/orange, right/blue).</div>
      </div>
    </header>

    <div class="controls">
      <button id="btn-start" class="small">Start Camera</button>
      <button id="btn-stop" class="small" disabled>Stop</button>
      <button id="btn-clear" class="small">Clear Text</button>
      <button id="btn-copy" class="small">Copy to clipboard</button>
      <label style="display:flex;align-items:center;gap:6px;color:var(--muted);margin-left:6px">
        <input id="mirror" type="checkbox" checked /> Mirror
      </label>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <label style="color:var(--muted)">Tap velocity</label>
        <input id="vel" type="range" min="2" max="40" value="10" />
      </div>
    </div>

    <div class="stage">
      <div class="video-wrap" id="videoWrap">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>
        <div id="toast" class="toast" aria-hidden="true"></div>
      </div>

      <div class="side">
        <div>
          <textarea id="typed" class="textbox" placeholder="Typed text will appear here..." readonly></textarea>
          <div class="hint">
            Tip: pinch (touch) your thumb to your index finger to switch keyboard layout. Use:
            index finger = type hovered key,
            middle finger = backspace,
            thumb = Enter.
          </div>

          <div class="legend">
            <div><span class="dot" style="background:#ff8a00"></span> Left hand (orange)</div>
            <div><span class="dot" style="background:#2aa4ff"></span> Right hand (blue)</div>
          </div>

          <div class="row" style="margin-top:8px">
            <div class="kbd-mode">
              <label class="key-count">Layout:</label>
              <select id="layout">
                <option value="qwerty">QWERTY (default)</option>
                <option value="numeric">Numeric</option>
                <option value="symbols">Symbols</option>
              </select>
            </div>
          </div>

          <div class="row">
            <button id="btn-calibrate">Calibrate Keyboard Area</button>
            <button id="btn-reset-cal">Reset Area</button>
          </div>

          <div class="row" style="margin-top:10px">
            <button id="btn-save" title="Save current text to localStorage">Save text</button>
            <button id="btn-load" title="Load saved text from localStorage">Load saved</button>
            <button id="btn-download" title="Download index.html and run locally">Download (single-file)</button>
          </div>

        </div>
      </div>
    </div>

    <footer>
      Prototype: gesture heuristics only. For production, use extra sensors or ML models to increase robustness.
    </footer>
  </div>

  <!-- MediaPipe scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
  // Finger indices from MediaPipe landmarks
  const TIP = { THUMB:4, INDEX:8, MIDDLE:12, RING:16, PINKY:20 };

  (function(){
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('btn-start');
    const stopBtn = document.getElementById('btn-stop');
    const copyBtn = document.getElementById('btn-copy');
    const clearBtn = document.getElementById('btn-clear');
    const typed = document.getElementById('typed');
    const velRange = document.getElementById('vel');
    const mirrorToggle = document.getElementById('mirror');
    const layoutSelect = document.getElementById('layout');
    const calBtn = document.getElementById('btn-calibrate');
    const resetCalBtn = document.getElementById('btn-reset-cal');
    const toastEl = document.getElementById('toast');

    let camera = null;
    let hands = null;
    let videoWidth = 640, videoHeight = 480;
    let keyboardArea = null;
    let isCalibrating = false;
    let calStart = null;

    // Colors per handedness
    const COLORS = {
      Left: { fill: '#ff8a00', stroke: '#ffb480' },
      Right: { fill: '#2aa4ff', stroke: '#8fd7ff' }
    };

    // Per-hand state includes per-finger substate
    const handState = {
      Left: makeHandState(),
      Right: makeHandState()
    };

    function makeHandState(){
      return {
        // finger states keyed by 'thumb','index','middle'
        fingers: {
          thumb: { lastY:null, lastTs:null, lastHoveredKey:null, lastTapTs:0 },
          index: { lastY:null, lastTs:null, lastHoveredKey:null, lastTapTs:0 },
          middle:{ lastY:null, lastTs:null, lastHoveredKey:null, lastTapTs:0 }
        },
        lastPinchTs: 0
      };
    }

    // Keyboard layouts
    const layouts = {
      qwerty: [
        "qwertyuiop".split(''),
        "asdfghjkl".split(''),
        "zxcvbnm".split(''),
        ["Space"]
      ],
      numeric: [
        ["1","2","3","4","5"],
        ["6","7","8","9","0"],
        ["-","/",".","Enter"]
      ],
      symbols: [
        ["!","@","#","$","%","^","&","*","(",")"],
        ["_","+","{","}","[","]","|",";",":"],
        ["'",'"',",",".","?","/","\\","<",">"],
      ]
    };
    const layoutKeys = Object.keys(layouts);
    let layoutIndex = 0; // sync with select

    function fitCanvas(){
      const wrap = document.getElementById('videoWrap');
      canvas.width = wrap.clientWidth;
      canvas.height = wrap.clientHeight;
      videoWidth = canvas.width; videoHeight = canvas.height;
    }
    window.addEventListener('resize', fitCanvas);

    function drawKeyboard(){
      if(!keyboardArea){
        keyboardArea = {
          x: canvas.width * 0.05,
          y: canvas.height * 0.60,
          w: canvas.width * 0.9,
          h: canvas.height * 0.35
        };
      }
      const L = layouts[layoutSelect.value] || layouts.qwerty;
      ctx.save();
      ctx.fillStyle = 'rgba(10,12,16,0.5)';
      ctx.fillRect(keyboardArea.x, keyboardArea.y, keyboardArea.w, keyboardArea.h);

      const rows = L.length;
      const rowH = keyboardArea.h / rows;
      for(let r=0;r<rows;r++){
        const row = L[r];
        const cols = row.length;
        const padding = 6;
        const keyW = (keyboardArea.w - (cols+1)*padding) / cols;
        for(let c=0;c<cols;c++){
          const kx = keyboardArea.x + padding + c*(keyW + padding);
          const ky = keyboardArea.y + r*rowH + padding/1.5;
          const kw = (r === rows-1 && row[0] === "Space") ? keyboardArea.w - padding*2 : keyW;
          const kh = rowH - padding*1.5;
          const label = row[c];

          // check hover highlights from any finger/hand and composite colors
          let composite = null;
          for(const hname of ['Left','Right']){
            const hs = handState[hname];
            for(const fname of ['index','middle','thumb']){
              const f = hs.fingers[fname];
              if(f && f.lastHoveredKey && f.lastHoveredKey.row===r && f.lastHoveredKey.col===c){
                // give priority index > middle > thumb in visual mixing
                const base = COLORS[hname].fill;
                composite = composite ? composite : base;
                // Don't break - allow both hands to contribute; we keep first found to keep visuals simple
                if(fname === 'index'){ break; }
              }
            }
            if(composite && composite === COLORS.Left.fill) break;
          }

          if(composite){
            ctx.fillStyle = hexToRgba(composite, 0.92);
          } else {
            ctx.fillStyle = 'rgba(30,41,59,0.88)';
          }

          ctx.strokeStyle = "rgba(255,255,255,0.03)";
          roundRect(ctx, kx, ky, kw, kh, 8, true, true);

          ctx.fillStyle = '#e6eef6';
          ctx.font = `${Math.max(12, kh*0.42)}px system-ui`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const tx = kx + kw/2;
          const ty = ky + kh/2;
          ctx.fillText(label, tx, ty);
        }
      }

      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.strokeRect(keyboardArea.x, keyboardArea.y, keyboardArea.w, keyboardArea.h);
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      if (typeof r === 'undefined') r = 5;
      if (typeof r === 'number') r = {tl: r, tr: r, br: r, bl: r};
      ctx.beginPath();
      ctx.moveTo(x + r.tl, y);
      ctx.lineTo(x + w - r.tr, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
      ctx.lineTo(x + w, y + h - r.br);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
      ctx.lineTo(x + r.bl, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
      ctx.lineTo(x, y + r.tl);
      ctx.quadraticCurveTo(x, y, x + r.tl, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function hexToRgba(hex, alpha){
      const c = hex.replace('#','');
      const r = parseInt(c.substring(0,2),16);
      const g = parseInt(c.substring(2,4),16);
      const b = parseInt(c.substring(4,6),16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function getKeyAt(x,y){
      if(!keyboardArea) return null;
      const L = layouts[layoutSelect.value] || layouts.qwerty;
      const relX = x - keyboardArea.x;
      const relY = y - keyboardArea.y;
      if(relX<0 || relY<0 || relX>keyboardArea.w || relY>keyboardArea.h) return null;
      const rows = L.length;
      const rowH = keyboardArea.h / rows;
      const r = Math.floor(relY / rowH);
      const row = L[r];
      const cols = row.length;
      const padding = 6;
      const keyW = (keyboardArea.w - (cols+1)*padding) / cols;
      for(let c=0;c<cols;c++){
        const kx = padding + c*(keyW + padding);
        const ky = r*rowH + padding/1.5;
        const kw = (r === rows-1 && row[0] === "Space") ? keyboardArea.w - padding*2 : keyW;
        const kh = rowH - padding*1.5;
        if(relX >= kx && relX <= kx+kw && relY >= ky && relY <= ky+kh){
          return {row:r,col:c,label:row[c],keyX:keyboardArea.x+kx,keyY:keyboardArea.y+ky,keyW:kw,keyH:kh};
        }
      }
      return null;
    }

    function registerKey(k){
      if(!k) return;
      const label = k.label;
      if(label === "Space") typed.value += " ";
      else if(label === "Enter") typed.value += "\n";
      else typed.value += label;
    }

    function doBackspace(){
      typed.value = typed.value.slice(0, -1);
    }

    function showToast(msg, ms=900){
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      toastEl.setAttribute('aria-hidden','false');
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=>{ toastEl.classList.remove('show'); toastEl.setAttribute('aria-hidden','true'); }, ms);
    }

    // Gesture: pinch thumb+index to cycle layout
    function handlePinchCycle(handed, thumbPos, indexPos, handBoxSize){
      const state = handState[handed];
      if(!state) return;
      // distance normalized by handBoxSize (approximate scaled)
      const dx = thumbPos.x - indexPos.x;
      const dy = thumbPos.y - indexPos.y;
      const dist = Math.hypot(dx,dy);
      const thresh = Math.max(28, handBoxSize * 0.12); // flexible threshold
      const now = performance.now();
      if(dist < thresh && (now - state.lastPinchTs) > 600){
        // cycle layout
        layoutIndex = (layoutIndex + 1) % layoutKeys.length;
        layoutSelect.value = layoutKeys[layoutIndex];
        showToast("Layout: " + layoutSelect.value);
        state.lastPinchTs = now;
      }
    }

    // Main results handler
    function onResults(results){
      fitCanvas();
      ctx.clearRect(0,0,canvas.width, canvas.height);
      drawKeyboard();

      // faint camera overlay
      ctx.save();
      ctx.globalAlpha = 0.06;
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();

      if(!results.multiHandLandmarks || results.multiHandLandmarks.length === 0){
        // no hand - we keep state but return
        return;
      }

      // Process up to two hands; use MediaPipe handedness if available
      for(let i=0;i<results.multiHandLandmarks.length;i++){
        const landmarks = results.multiHandLandmarks[i];
        const handed = (results.multiHandedness && results.multiHandedness[i] && results.multiHandedness[i].label) ? results.multiHandedness[i].label : (i === 0 ? 'Right' : 'Left');
        const state = handState[handed] || (handState[handed] = makeHandState());

        // compute approximate hand bounding box size to normalize pinch threshold
        let minX=1,minY=1,maxX=0,maxY=0;
        for(const p of landmarks){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
        const handBoxSize = Math.max((maxX-minX)*canvas.width, (maxY-minY)*canvas.height);

        // per-finger positions
        function mkPos(landmarkIndex){
          let x = landmarks[landmarkIndex].x * canvas.width;
          let y = landmarks[landmarkIndex].y * canvas.height;
          if(mirrorToggle.checked) x = canvas.width - x;
          return {x,y};
        }
        const thumbPos = mkPos(TIP.THUMB);
        const indexPos = mkPos(TIP.INDEX);
        const middlePos = mkPos(TIP.MIDDLE);

        // draw hand landmarks & colored pointers
        const col = COLORS[handed] ? COLORS[handed] : { fill:'#fff', stroke:'#fff' };
        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: col.stroke, lineWidth:2});
        drawLandmarks(ctx, landmarks, {color: col.fill, lineWidth:1, radius:2});

        // Draw finger tip markers larger for ease of seeing
        ctx.beginPath(); ctx.fillStyle = hexToRgba(col.fill,0.98); ctx.arc(indexPos.x, indexPos.y, 9, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.fillStyle = hexToRgba(col.fill,0.6); ctx.arc(middlePos.x, middlePos.y, 8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.fillStyle = hexToRgba(col.fill,0.72); ctx.arc(thumbPos.x, thumbPos.y, 8, 0, Math.PI*2); ctx.fill();

        // Update hovered keys for each finger
        const hoveredIndex = getKeyAt(indexPos.x, indexPos.y);
        const hoveredMiddle = getKeyAt(middlePos.x, middlePos.y);
        const hoveredThumb = getKeyAt(thumbPos.x, thumbPos.y);

        // helper to update finger state and detect major movement
        function processFinger(fingerName, pos, hovered, tipIndex){
          const f = state.fingers[fingerName];
          const now = performance.now();

          // store hovered key if present
          if(hovered){
            f.lastHoveredKey = { row: hovered.row, col: hovered.col, label: hovered.label, keyX: hovered.keyX, keyY: hovered.keyY, keyW: hovered.keyW, keyH: hovered.keyH };
          }

          // compute velocity in Y
          if(f.lastY !== null && f.lastTs !== null){
            const dt = Math.max(1, now - f.lastTs);
            const dy = pos.y - f.lastY;
            const velocity = (dy / dt) * 1000;
            const velThreshold = parseFloat(velRange.value) * 60;

            if(Math.abs(velocity) > velThreshold && (now - f.lastTapTs) > 350){
              // major movement detected for this finger on this hand
              // map finger commands:
              // index -> type last hovered key
              // middle -> backspace
              // thumb -> Enter
              if(fingerName === 'index'){
                if(f.lastHoveredKey){
                  registerKey(f.lastHoveredKey);
                }
              } else if(fingerName === 'middle'){
                doBackspace();
              } else if(fingerName === 'thumb'){
                // Special: if thumb hovered Space/Enter, prefer that; otherwise insert newline (Enter)
                if(f.lastHoveredKey && f.lastHoveredKey.label === 'Space'){
                  registerKey(f.lastHoveredKey);
                } else {
                  typed.value += "\n";
                }
              }
              f.lastTapTs = now;
            }
          }

          // update last positions
          f.lastY = pos.y;
          f.lastTs = now;
        }

        processFinger('index', indexPos, hoveredIndex, TIP.INDEX);
        processFinger('middle', middlePos, hoveredMiddle, TIP.MIDDLE);
        processFinger('thumb', thumbPos, hoveredThumb, TIP.THUMB);

        // pinch detection (thumb + index)
        handlePinchCycle(handed, thumbPos, indexPos, handBoxSize);
      }
    }

    function startCamera(){
      if(camera) return;
      hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });
      hands.onResults(onResults);

      camera = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 1280,
        height: 720
      });
      camera.start();
      startBtn.disabled = true;
      stopBtn.disabled = false;
      // keep layoutIndex in sync with select at start
      layoutIndex = layoutKeys.indexOf(layoutSelect.value);
      if(layoutIndex < 0) layoutIndex = 0;
    }

    function stopCamera(){
      if(camera){ camera.stop(); camera = null; }
      if(hands){ hands.close(); hands = null; }
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }

    // calibration: click-drag
    canvas.addEventListener('pointerdown', (ev)=>{
      if(!isCalibrating) return;
      calStart = {x:ev.offsetX, y:ev.offsetY};
    });
    canvas.addEventListener('pointerup', (ev)=>{
      if(!isCalibrating || !calStart) return;
      const x1 = Math.min(calStart.x, ev.offsetX);
      const x2 = Math.max(calStart.x, ev.offsetX);
      const y1 = Math.min(calStart.y, ev.offsetY);
      const y2 = Math.max(calStart.y, ev.offsetY);
      keyboardArea = {x:x1, y:y1, w:x2-x1, h:y2-y1};
      isCalibrating = false;
      calStart = null;
      calBtn.textContent = "Calibrate Keyboard Area";
    });

    calBtn.addEventListener('click', ()=>{
      isCalibrating = !isCalibrating;
      calBtn.textContent = isCalibrating ? "Click-drag on video to set area..." : "Calibrate Keyboard Area";
    });
    resetCalBtn.addEventListener('click', ()=>{ keyboardArea = null; });

    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);

    copyBtn.addEventListener('click', async ()=>{
      try{
        await navigator.clipboard.writeText(typed.value);
        copyBtn.textContent = "Copied!";
        setTimeout(()=>copyBtn.textContent = "Copy to clipboard", 1000);
      } catch(e){ alert("Copy failed: " + e); }
    });

    clearBtn.addEventListener('click', ()=>{ typed.value = ""; });

    layoutSelect.addEventListener('change', ()=>{
      // keep layoutIndex in sync and show toast
      layoutIndex = layoutKeys.indexOf(layoutSelect.value);
      showToast("Layout: " + layoutSelect.value);
    });

    document.getElementById('btn-save').addEventListener('click', ()=>{ localStorage.setItem('camkb_text', typed.value); alert('Saved'); });
    document.getElementById('btn-load').addEventListener('click', ()=>{ typed.value = localStorage.getItem('camkb_text') || ""; });

    document.getElementById('btn-download').addEventListener('click', ()=>{
      const doctype = "<!doctype html>\n";
      const html = document.documentElement.outerHTML;
      const blob = new Blob([doctype+html], {type:'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'cam-invisible-keyboard-gestures.html';
      a.click();
      URL.revokeObjectURL(url);
    });

    // initial sizing
    fitCanvas();
    keyboardArea = null;
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

  })();
  </script>
</body>
</html>
