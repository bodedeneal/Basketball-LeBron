<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Basketball Arcade Scoreboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
  <style>
    body { background: #222; color: #fff; font-family: Arial, sans-serif; margin:0; padding:0; text-align:center;}
    h1 { font-size:2em; margin:20px; }
    #video { border-radius: 16px; box-shadow: 0 0 20px #111; width: 640px; max-width:95vw; margin-bottom:12px;}
    .scoreboard { display:flex; justify-content:center; gap:60px; margin:24px 0;}
    .player { background:#333; padding:18px 28px; border-radius:16px; min-width:160px; box-shadow: 0 0 14px #444;}
    .player.active { border:3px solid #FFA500; box-shadow: 0 0 22px #FFA500;}
    .score { font-size:2.2em; font-weight:bold; margin:6px 0;}
    .info { font-size:1.1em; margin:6px 0;}
    #status { margin:16px 0; color:#FFA500;}
    #canvas { display:none;}
    .arcade-controls { margin:16px 0; }
    .arcade-controls select, .arcade-controls button { font-size:1em; margin:0 8px; }
    .timer { font-size:2em; color:#FFA500; margin:10px 0;}
    .final-score { color:#FFD700; font-size:2em; margin:15px 0; }
    @media (max-width:700px) { #video { width:99vw; } .scoreboard { gap:6vw; } .player { padding:12px 4vw; } }
  </style>
</head>
<body>
  <h1>üèÄ Basketball Scoreboard & Arcade Hub</h1>
  <div class="arcade-controls">
    <label for="mode">Mode:</label>
    <select id="mode">
      <option value="regular">Regular</option>
      <option value="arcade">Arcade</option>
    </select>
    <label for="arcade-time">Arcade Time:</label>
    <select id="arcade-time">
      <option value="60">1 min</option>
      <option value="120">2 min</option>
      <option value="180">3 min</option>
      <option value="300">5 min</option>
    </select>
    <label for="ball-color">Ball Color:</label>
    <select id="ball-color">
      <option value="orange">Orange</option>
      <option value="red">Red</option>
      <option value="black">Black</option>
      <option value="brown">Brown</option>
    </select>
    <button onclick="startArcade()">Start Arcade</button>
  </div>
  <div class="scoreboard" id="scoreboard">
    <div id="player1" class="player">
      <div id="desc1" class="info">Player 1</div>
      <div class="score" id="score1">0</div>
      <div id="possession1" class="info"></div>
    </div>
    <div id="player2" class="player">
      <div id="desc2" class="info">Player 2</div>
      <div class="score" id="score2">0</div>
      <div id="possession2" class="info"></div>
    </div>
  </div>
  <div id="timer" class="timer" style="display:none;"></div>
  <div id="finalScore" class="final-score" style="display:none;"></div>
  <div id="status">Loading AI models and camera...</div>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas" width="640" height="480"></canvas>
<script>
let score = [0,0];
let possession = 0;
let lastBallHolder = 0;
let playerFeatures = [{}, {}];
let lastBallDetected = false, lastThrowTime = 0;
let arcadeActive = false, arcadeTimeLeft = 60, arcadeTimerInterval, arcadeScore = 0;
let ballColor = "orange";
let net = null;

function updateUI() {
  document.getElementById('score1').textContent = score[0];
  document.getElementById('score2').textContent = score[1];
  document.getElementById('player1').classList.toggle('active', possession === 0);
  document.getElementById('player2').classList.toggle('active', possession === 1);
  document.getElementById('possession1').textContent = possession === 0 ? "üèÄ Has Ball" : "";
  document.getElementById('possession2').textContent = possession === 1 ? "üèÄ Has Ball" : "";
  document.getElementById('desc1').textContent = describePlayer(playerFeatures[0]) || "Player 1";
  document.getElementById('desc2').textContent = describePlayer(playerFeatures[1]) || "Player 2";
}
function describePlayer(f) {
  if (!f) return "";
  let desc = [];
  if (f.hairColor) desc.push(f.hairColor + " hair");
  if (f.top) desc.push(f.top + " shirt");
  return desc.join(", ");
}

function addPoint() {
  if (arcadeActive) {
    arcadeScore += 2;
    document.getElementById('status').textContent = `Arcade: +2 points!`;
    updateArcadeUI();
  } else {
    score[lastBallHolder] += 2;
    document.getElementById('status').textContent = `2 points for: ${describePlayer(playerFeatures[lastBallHolder]) || 'Player '+(lastBallHolder+1)}`;
    updateUI();
  }
}

function updateArcadeUI() {
  document.getElementById('scoreboard').style.display = "none";
  document.getElementById('timer').style.display = "";
  document.getElementById('finalScore').style.display = "none";
  document.getElementById('timer').textContent = `Time left: ${arcadeTimeLeft}s | Score: ${arcadeScore}`;
}

function endArcade() {
  arcadeActive = false;
  clearInterval(arcadeTimerInterval);
  document.getElementById('timer').style.display = "none";
  document.getElementById('finalScore').style.display = "";
  document.getElementById('finalScore').textContent = `Final Score: ${arcadeScore}`;
  document.getElementById('scoreboard').style.display = "";
  arcadeScore = 0;
  document.getElementById('status').textContent = "Arcade Mode finished! Try again?";
}

function startArcade() {
  let mode = document.getElementById('mode').value;
  if (mode !== "arcade") {
    arcadeActive = false;
    document.getElementById('timer').style.display = "none";
    document.getElementById('finalScore').style.display = "none";
    document.getElementById('scoreboard').style.display = "";
    document.getElementById('status').textContent = "Regular Mode";
    return;
  }
  arcadeActive = true;
  arcadeTimeLeft = parseInt(document.getElementById('arcade-time').value);
  ballColor = document.getElementById('ball-color').value;
  arcadeScore = 0;
  document.getElementById('finalScore').style.display = "none";
  document.getElementById('scoreboard').style.display = "none";
  document.getElementById('timer').style.display = "";
  document.getElementById('status').textContent = "Arcade Mode started! Score as much as you can!";
  updateArcadeUI();
  clearInterval(arcadeTimerInterval);
  arcadeTimerInterval = setInterval(() => {
    arcadeTimeLeft--;
    updateArcadeUI();
    if (arcadeTimeLeft <= 0) endArcade();
  }, 1000);
}

const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

navigator.mediaDevices.getUserMedia({video:true}).then(stream=>{
  video.srcObject = stream;
  video.onloadedmetadata = () => {
    document.getElementById('status').textContent = "Camera ready. Loading PoseNet...";
    loadAI();
  }
}).catch(err=>{
  document.getElementById('status').textContent = "Camera access denied.";
});

async function loadAI() {
  net = await posenet.load();
  document.getElementById('status').textContent = "AI Ready. Detecting players and ball...";
  processFrame();
}
function processFrame() {
  if (video.readyState === video.HAVE_ENOUGH_DATA) {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    net.estimateMultiplePoses(video, {flipHorizontal:false, maxDetections:2}).then(poses=>{
      let players = poses.filter(p=>p.score>0.3);
      while (players.length<2) players.push({});
      for (let i=0;i<2;i++) {
        playerFeatures[i] = analyzeAppearance(players[i]);
      }
      let ball = detectColoredBall(ctx, canvas, ballColor);
      let holder = findBallHolderTorso(players, ball);

      if (holder!==null) {
        possession = holder;
        lastBallHolder = holder;
      }
      if (!arcadeActive) updateUI();

      let now = Date.now();
      if (ball.detected && !lastBallDetected && now-lastThrowTime>2000) {
        addPoint();
        lastThrowTime = now;
      }
      lastBallDetected = ball.detected;
    });
  }
  requestAnimationFrame(processFrame);
}

// Hair color detection
function analyzeAppearance(pose) {
  if (!pose || !pose.keypoints) return null;
  let nose = pose.keypoints.find(k=>k.part==="nose")?.position;
  let leftEye = pose.keypoints.find(k=>k.part==="leftEye")?.position;
  let rightEye = pose.keypoints.find(k=>k.part==="rightEye")?.position;
  let hairSamplePoints = [];
  if(nose) hairSamplePoints.push({x: nose.x, y: nose.y - 35});
  if(leftEye && rightEye) hairSamplePoints.push({x: (leftEye.x + rightEye.x)/2, y: (leftEye.y + rightEye.y)/2 - 30});
  let leftEar = pose.keypoints.find(k=>k.part==="leftEar")?.position;
  let rightEar = pose.keypoints.find(k=>k.part==="rightEar")?.position;
  if(leftEar) hairSamplePoints.push({x: leftEar.x, y: leftEar.y - 20});
  if(rightEar) hairSamplePoints.push({x: rightEar.x, y: rightEar.y - 20});
  let hairColor = getAverageHairColor(ctx, hairSamplePoints);

  let leftShoulder = pose.keypoints.find(k=>k.part==="leftShoulder");
  let rightShoulder = pose.keypoints.find(k=>k.part==="rightShoulder");
  let topX = Math.round((leftShoulder?.position.x+rightShoulder?.position.x)/2 || 0);
  let topY = Math.round((leftShoulder?.position.y+rightShoulder?.position.y)/2 + 30 || 0);
  let color = sampleColor(ctx, topX, topY);
  let topColor = colorToName(color);

  return {hairColor: hairColor, top: topColor};
}

function getAverageHairColor(ctx, points) {
  let colors = [];
  for(let pt of points) {
    let c = sampleColor(ctx, Math.round(pt.x), Math.round(pt.y));
    colors.push(c);
  }
  let avg = averageColor(colors);
  return hairColorName(avg);
}
function averageColor(colors) {
  let r=0,g=0,b=0,n=colors.length;
  for(let c of colors) { r+=c.r; g+=c.g; b+=c.b; }
  return {r:Math.round(r/n),g:Math.round(g/n),b:Math.round(b/n)};
}
function hairColorName({r,g,b}) {
  if(r>190 && g>170 && b<120) return "Blonde";
  if(r<60 && g<60 && b<70) return "Black";
  if(r>100 && r<180 && g>60 && g<120 && b>40 && b<90) return "Brown";
  if(r>150 && g<80 && b<80) return "Red";
  if(r>180 && g>180 && b>180) return "Gray";
  return "Brunette";
}
function sampleColor(ctx, x, y) {
  try {
    let d = ctx.getImageData(x, y, 1, 1).data;
    return {r:d[0],g:d[1],b:d[2]};
  } catch { return {r:0,g:0,b:0}; }
}
function colorToName({r,g,b}) {
  if (r>180 && g>180 && b>180) return "White";
  if (r<60 && g<60 && b<60) return "Black";
  if (r>120 && g>120 && b<60) return "Yellow";
  if (r>150 && g<80 && b<80) return "Red";
  if (g>150 && r<100 && b<100) return "Green";
  if (b>150 && r<100 && g<100) return "Blue";
  if (r>100 && b>100 && g<100) return "Purple";
  if (r>100 && g>100 && b<100) return "Gray";
  if (r>100 && g>70 && g<140 && b>40 && b<90) return "Brown";
  return "";
}

// Ball detection for multiple colors
function detectColoredBall(ctx, canvas, color) {
  let img = ctx.getImageData(0,0,canvas.width,canvas.height), match=0, total=img.data.length/4, cx=0, cy=0;
  for(let i=0;i<img.data.length;i+=4){
    let r=img.data[i],g=img.data[i+1],b=img.data[i+2];
    let isMatch = false;
    if(color==="orange") isMatch = r>170 && g>70 && g<200 && b<80;
    if(color==="red") isMatch = r>180 && g<100 && b<100;
    if(color==="black") isMatch = r<60 && g<60 && b<60;
    if(color==="brown") isMatch = r>100 && g>70 && g<140 && b>40 && b<90;
    if(isMatch){
      match++;
      let px=(i/4)%canvas.width, py=Math.floor((i/4)/canvas.width);
      cx+=px; cy+=py;
    }
  }
  let detected = match/total > 0.01;
  if (!detected) return {detected:false};
  cx = Math.round(cx/match); cy = Math.round(cy/match);
  return {detected:true, x:cx, y:cy};
}

// Ball holder detection
function findBallHolderTorso(players, ball) {
  if (!ball.detected) return null;
  let minDist = Infinity, holder=null;
  for (let i=0;i<2;i++) {
    let pose = players[i];
    if (!pose || !pose.keypoints) continue;
    let leftShoulder = pose.keypoints.find(k=>k.part==="leftShoulder")?.position;
    let rightShoulder = pose.keypoints.find(k=>k.part==="rightShoulder")?.position;
    let leftHip = pose.keypoints.find(k=>k.part==="leftHip")?.position;
    let rightHip = pose.keypoints.find(k=>k.part==="rightHip")?.position;
    if (!leftShoulder || !rightShoulder || !leftHip || !rightHip) continue;
    let torsoX = (leftShoulder.x + rightShoulder.x + leftHip.x + rightHip.x) / 4;
    let torsoY = (leftShoulder.y + rightShoulder.y + leftHip.y + rightHip.y) / 4;
    let dist = Math.hypot(torsoX-ball.x, torsoY-ball.y);
    if (dist<120 && dist<minDist) { minDist = dist; holder = i; }
  }
  return holder;
}

updateUI();
</script>
</body>
</html>
